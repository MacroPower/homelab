{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "additionalProperties": true,
  "properties": {
    "additionalLabels": {
      "additionalProperties": true,
      "description": "additional labels to add to all resources",
      "required": [],
      "title": "additionalLabels",
      "type": "object"
    },
    "affinity": {
      "additionalProperties": true,
      "description": "pod affinity",
      "required": [],
      "title": "affinity",
      "type": "object"
    },
    "clusterDomain": {
      "default": "",
      "description": "Sets the `CLUSTER_DOMAIN` environment variable,\nit defines how internal Kubernetes services managed by the operator are addressed.\nBy default, this is empty, and internal services are addressed without a cluster domain specified, i.e., a\nrelative domain name that will resolve regardless of if a custom domain is configured for the cluster. If you\nwish to have services addressed using their FQDNs, you can specify the cluster domain explicitly, e.g., \"cluster.local\"\nfor the default Kubernetes configuration.",
      "required": [],
      "title": "clusterDomain",
      "type": "string"
    },
    "crds": {
      "additionalProperties": true,
      "properties": {
        "immutable": {
          "default": true,
          "description": "Immutable CustomResourceDefinitions are installed only once using `crds/` directory\nand require manual upgrade by `kubectl apply`.\nMutable CRDs are installed and upgraded together with the Helm chart using `templates/` directory\nwithout manual `kubectl apply` step required.\nUse `helm upgrade -i --take-ownership` when switching to mutable CRDs for the first time only.\nBoth types of CRDs are protected on the Helm chart uninstall to avoid cascading deletion.",
          "required": [],
          "title": "immutable",
          "type": "boolean"
        }
      },
      "required": [],
      "title": "crds",
      "type": "object"
    },
    "dashboard": {
      "additionalProperties": true,
      "properties": {
        "annotations": {
          "additionalProperties": true,
          "description": "Annotations to add to the Grafana dashboard ConfigMap",
          "required": [],
          "title": "annotations",
          "type": "object"
        },
        "enabled": {
          "default": false,
          "description": "Whether to create a ConfigMap containing a dashboard monitoring the operator metrics.\nConsider enabling this if you are enabling the ServiceMonitor.\nOptionally, a GrafanaDashboard CR can be manually created pointing to the Grafana.com dashboard ID 22785\nhttps://grafana.com/grafana/dashboards/22785-grafana-operator/\nThe Grafana.com dashboard is maintained by the community and does not necessarily match the JSON definition in this repository.",
          "required": [],
          "title": "enabled",
          "type": "boolean"
        },
        "labels": {
          "additionalProperties": true,
          "description": "Labels to add to the Grafana dashboard ConfigMap",
          "required": [],
          "title": "labels",
          "type": "object"
        }
      },
      "required": [],
      "title": "dashboard",
      "type": "object"
    },
    "enforceCacheLabels": {
      "default": "safe",
      "description": "Sets the `ENFORCE_CACHE_LABELS` environment variable,\nAllows to tweak how caching of various Kubernetes resources works inside the operator.\nValid values are \"off\", \"safe\", and \"all\".\nWhen set to \"off\", all resources are cached (including Deployments, Services, Ingresses, and any other native resources that the operator interacts with), which results in much higher memory usage (essentially, grows with cluster size).\nWhen set to `safe`, ConfigMaps and Secrets are not cached, all other native resources are cached only when they have `app.kubernetes.io/managed-by: grafana-operator` label. The label is automatically set on all resources that are created/owned by the operator (applicable to any mode).\nWhen set to `all`, only resources that have `app.kubernetes.io/managed-by: grafana-operator` are cached. The caveat is that ConfigMaps and Secrets can be seen by the operator only if they have the label. Thus, usage of this mode requires more careful planning.",
      "required": [],
      "title": "enforceCacheLabels",
      "type": "string"
    },
    "env": {
      "description": "Additional environment variables",
      "items": {
        "required": []
      },
      "required": [],
      "title": "env",
      "type": "array"
    },
    "extraObjects": {
      "description": "Array of extra K8s objects to deploy",
      "items": {
        "required": []
      },
      "required": [],
      "title": "extraObjects",
      "type": "array"
    },
    "fullnameOverride": {
      "default": "",
      "description": "Overrides the fully qualified app name.",
      "required": [],
      "title": "fullnameOverride",
      "type": "string"
    },
    "global": {
      "additionalProperties": true,
      "description": "Global values are values that can be accessed from any chart or subchart by exactly the same name.",
      "required": [],
      "title": "global",
      "type": "object"
    },
    "image": {
      "additionalProperties": true,
      "properties": {
        "pullPolicy": {
          "default": "IfNotPresent",
          "description": "The image pull policy to use in grafana operator container",
          "required": [],
          "title": "pullPolicy",
          "type": "string"
        },
        "repository": {
          "default": "ghcr.io/grafana/grafana-operator",
          "description": "grafana operator image repository",
          "required": [],
          "title": "repository",
          "type": "string"
        },
        "tag": {
          "default": "",
          "description": "Overrides the image tag whose default is the chart appVersion.",
          "required": [],
          "title": "tag",
          "type": "string"
        }
      },
      "required": [],
      "title": "image",
      "type": "object"
    },
    "imagePullSecrets": {
      "description": "image pull secrets",
      "items": {
        "required": []
      },
      "required": [],
      "title": "imagePullSecrets",
      "type": "array"
    },
    "isOpenShift": {
      "default": false,
      "description": "Determines if the target cluster is OpenShift. Additional rbac permissions for routes will be added on OpenShift",
      "required": [],
      "title": "isOpenShift",
      "type": "boolean"
    },
    "leaderElect": {
      "default": true,
      "description": "This is recommended in most scenarios, even when only running a single instance of the operator.",
      "required": [],
      "title": "leaderElect",
      "type": "boolean"
    },
    "logging": {
      "additionalProperties": true,
      "properties": {
        "encoder": {
          "default": "console",
          "description": "Log encoding (\"console\", \"json\")",
          "required": [],
          "title": "encoder",
          "type": "string"
        },
        "level": {
          "default": "info",
          "description": "Configure the verbosity of logging (\"debug\", \"error\", \"info\")",
          "required": [],
          "title": "level",
          "type": "string"
        },
        "time": {
          "default": "rfc3339",
          "description": "Time encoding (\"epoch\", \"iso8601\", \"millis\", \"nano\", \"rfc3339\", \"rfc3339nano\")",
          "required": [],
          "title": "time",
          "type": "string"
        }
      },
      "required": [],
      "title": "logging",
      "type": "object"
    },
    "maxConcurrentReconciles": {
      "default": 1,
      "description": "Maximum number of concurrent reconciles per Custom Resource.",
      "required": [],
      "title": "maxConcurrentReconciles",
      "type": "integer"
    },
    "metricsService": {
      "additionalProperties": true,
      "properties": {
        "metricsPort": {
          "default": 9090,
          "description": "metrics service port",
          "required": [],
          "title": "metricsPort",
          "type": "integer"
        },
        "pprofPort": {
          "default": 8888,
          "description": "port for the pprof profiling endpoint",
          "required": [],
          "title": "pprofPort",
          "type": "integer"
        },
        "type": {
          "default": "ClusterIP",
          "description": "metrics service type",
          "required": [],
          "title": "type",
          "type": "string"
        }
      },
      "required": [],
      "title": "metricsService",
      "type": "object"
    },
    "nameOverride": {
      "default": "",
      "description": "Overrides the name of the chart.",
      "required": [],
      "title": "nameOverride",
      "type": "string"
    },
    "namespaceOverride": {
      "default": "",
      "description": "Overrides the namespace name.",
      "required": [],
      "title": "namespaceOverride",
      "type": "string"
    },
    "namespaceScope": {
      "default": false,
      "description": "If the operator should run in namespace-scope or not,\nif true the operator will only be able to manage instances in the same namespace",
      "required": [],
      "title": "namespaceScope",
      "type": "boolean"
    },
    "nodeSelector": {
      "additionalProperties": true,
      "description": "pod node selector",
      "required": [],
      "title": "nodeSelector",
      "type": "object"
    },
    "podAnnotations": {
      "additionalProperties": true,
      "description": "pod annotations",
      "required": [],
      "title": "podAnnotations",
      "type": "object"
    },
    "podLabels": {
      "additionalProperties": true,
      "description": "pod labels",
      "required": [],
      "title": "podLabels",
      "type": "object"
    },
    "podSecurityContext": {
      "additionalProperties": true,
      "description": "pod security context",
      "required": [],
      "title": "podSecurityContext",
      "type": "object"
    },
    "priorityClassName": {
      "default": "",
      "description": "pod priority class name",
      "required": [],
      "title": "priorityClassName",
      "type": "string"
    },
    "rbac": {
      "additionalProperties": true,
      "properties": {
        "create": {
          "default": true,
          "description": "Specifies whether to create the ClusterRole and ClusterRoleBinding.\nIf \"namespaceScope\" is true or \"watchNamespaces\" is set, this will create Role and RoleBinding instead.",
          "required": [],
          "title": "create",
          "type": "boolean"
        }
      },
      "required": [],
      "title": "rbac",
      "type": "object"
    },
    "replicas": {
      "default": 1,
      "description": "The number of operators to run simultaneously.\nWith leader election, only one instance reconciles CRs preventing duplicate reconciliations.\nNote: Multiple replicas increase stability, it does not increase throughput.",
      "required": [],
      "title": "replicas",
      "type": "integer"
    },
    "resources": {
      "additionalProperties": true,
      "description": "grafana operator container resources",
      "required": [],
      "title": "resources",
      "type": "object"
    },
    "securityContext": {
      "additionalProperties": true,
      "properties": {
        "allowPrivilegeEscalation": {
          "default": false,
          "description": "Whether to allow privilege escalation",
          "required": [],
          "title": "allowPrivilegeEscalation",
          "type": "boolean"
        },
        "capabilities": {
          "additionalProperties": true,
          "description": "A list of capabilities to drop",
          "properties": {
            "drop": {
              "items": {
                "required": [],
                "type": "string"
              },
              "required": [],
              "title": "drop",
              "type": "array"
            }
          },
          "required": [],
          "title": "capabilities",
          "type": "object"
        },
        "readOnlyRootFilesystem": {
          "default": true,
          "description": "Whether to allow writing to the root filesystem",
          "required": [],
          "title": "readOnlyRootFilesystem",
          "type": "boolean"
        },
        "runAsNonRoot": {
          "default": true,
          "description": "Whether to require a container to run as a non-root user",
          "required": [],
          "title": "runAsNonRoot",
          "type": "boolean"
        }
      },
      "required": [],
      "title": "securityContext",
      "type": "object"
    },
    "serviceAccount": {
      "additionalProperties": true,
      "properties": {
        "annotations": {
          "additionalProperties": true,
          "description": "Annotations to add to the service account",
          "required": [],
          "title": "annotations",
          "type": "object"
        },
        "create": {
          "default": true,
          "description": "Specifies whether a service account should be created",
          "required": [],
          "title": "create",
          "type": "boolean"
        },
        "name": {
          "default": "",
          "description": "The name of the service account to use.\nIf not set and create is true, a name is generated using the fullname template",
          "required": [],
          "title": "name",
          "type": "string"
        }
      },
      "required": [],
      "title": "serviceAccount",
      "type": "object"
    },
    "serviceMonitor": {
      "additionalProperties": true,
      "properties": {
        "additionalLabels": {
          "additionalProperties": true,
          "description": "Set of labels to transfer from the Kubernetes Service onto the target",
          "required": [],
          "title": "additionalLabels",
          "type": "object"
        },
        "enabled": {
          "default": false,
          "description": "Whether to create a ServiceMonitor",
          "required": [],
          "title": "enabled",
          "type": "boolean"
        },
        "interval": {
          "default": "1m",
          "description": "Set how frequently Prometheus should scrape",
          "required": [],
          "title": "interval",
          "type": "string"
        },
        "metricRelabelings": {
          "description": "MetricRelabelConfigs to apply to samples before ingestion",
          "items": {
            "required": []
          },
          "required": [],
          "title": "metricRelabelings",
          "type": "array"
        },
        "relabelings": {
          "description": "Set relabel_configs as per https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config",
          "items": {
            "required": []
          },
          "required": [],
          "title": "relabelings",
          "type": "array"
        },
        "scrapeTimeout": {
          "default": "10s",
          "description": "Set timeout for scrape",
          "required": [],
          "title": "scrapeTimeout",
          "type": "string"
        },
        "targetLabels": {
          "description": "Set of labels to transfer from the Kubernetes Service onto the target",
          "items": {
            "required": []
          },
          "required": [],
          "title": "targetLabels",
          "type": "array"
        },
        "telemetryPath": {
          "default": "/metrics",
          "description": "Set path to metrics path",
          "required": [],
          "title": "telemetryPath",
          "type": "string"
        }
      },
      "required": [],
      "title": "serviceMonitor",
      "type": "object"
    },
    "tolerations": {
      "description": "pod tolerations",
      "items": {
        "required": []
      },
      "required": [],
      "title": "tolerations",
      "type": "array"
    },
    "watchLabelSelectors": {
      "default": "",
      "description": "Sets the `WATCH_LABEL_SELECTORS` environment variable,\nit defines which CRs are watched according to their labels.\nBy default, the operator watches all CRs. To make it watch only a subset of CRs, define the variable as a *stringified label selector*.\nSee also: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\nBeware: Always label Grafana CRs before enabling to ensure labels are inherited.\n# Existing Secrets/ConfigMaps referenced in CRs also need to be labeled to continue working.",
      "required": [],
      "title": "watchLabelSelectors",
      "type": "string"
    },
    "watchNamespaceSelector": {
      "default": "",
      "description": "Sets the `WATCH_NAMESPACE_SELECTOR` environment variable,\nit defines which namespaces the operator should be listening for based on a namespace label (e.g. `\"environment: dev\"`).\nBy default, the operator watches all namespaces. To make it watch only its own namespace, check out `namespaceScope` option instead.",
      "required": [],
      "title": "watchNamespaceSelector",
      "type": "string"
    },
    "watchNamespaces": {
      "default": "",
      "description": "Sets the `WATCH_NAMESPACE` environment variable,\nit defines which namespaces the operator should be listening for (e.g. `\"grafana, foo\"`).\nBy default, the operator watches all namespaces. To make it watch only its own namespace, check out `namespaceScope` option instead.",
      "required": [],
      "title": "watchNamespaces",
      "type": "string"
    }
  },
  "required": [],
  "type": "object"
}